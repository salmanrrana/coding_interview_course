// // --- Directions
// // Print out the n-th entry in the fibonacci series.
// // The fibonacci series is an ordering of numbers where
// // each number is the sum of the preceeding two.
// // For example, the sequence
// //  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
// // forms the first ten entries of the fibonacci series.
// // Example:
// //   fib(4) === 3
//
// // SOLUTION 3 - MEMOIZATION
// function memoize(fn) {
//   //declare some storage area to store those results
//   // record of previous calls to function
//   const cache = {};
//   // receive some inner arguments for this function below
//   // we dont know how many arguments are going to be sent into this function
//   // ...args tells javascript, we do not how many arguments this will receive
//   return function(...args) {
//     //check to see if this function has ever been called with a particular set of arguments before
//     if (cache[args]) {
//       // if we have called it, then this will cache it - this is caching mechanism
//       return cache[args];
//     }
//       // if we have not called the function with a set of arguments we will
//
//       const result = fn.apply(this, args);
//       cache[args] = result;
//
//       return result
//   }
// }
//
// // set up our slow algorithm
// function slowFib(n) {
//   if (n < 2) {
//     return n;
//   }
//   return fib(n - 1) + fib(n - 2);
// }
//
// const fib = memoize(slowFib)
//
// module.exports = fib;
//
//
// // SOLUTION 2 - recursive solution
// // function fib(n) {
// //   if (n < 2) {
// //     return n;
// //   }
// //
// //   return fib(n - 1) + fib(n - 2);
// // }
//
//
//
//
// // SOLUTION 1 - iterative solution
// // function fib(n) {
// //   // create an array - with the first two results
// //   // since it cannot be generated by a for loop (manually enter [0,1])
// //   const result = [0, 1];
// //
// //   // loop through the array starting at 2 (i=2)
// //   for (let i = 2; i <= n; i++) {
// //     // Now we need to pull out the previous two records in the array
// //     const a = result[i - 1];
// //     const b = result[i - 2];
// //
// //     // add the results together and push in the results array
// //     result.push(a + b);
// //   }
// //
// //   return result[n];
// // }

// **************SECOND ROUND**************

// --- Directions
// Print out the n-th entry in the fibonacci series.
// The fibonacci series is an ordering of numbers where
// each number is the sum of the preceeding two.
// For example, the sequence
//  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
// forms the first ten entries of the fibonacci series.
// Example:
//   fib(4) === 3

// SOLUTION - iterative
// function fib(n) {
//   let result = [0, 1];
//
//   for (let i = 2; i <= n; i++) {
//     const a = result[i - 1];
//     const b = result[i - 2];
//     result.push(a + b);
//   }
//
//   return result[n];
// }

// SOLUTION - recursive solution
// function fib(n) {
//   // base case
//   if (n < 2) {
//     return n;
//   }
//
//   return fib(n - 1) + fib(n - 2);
// }

// IMPROVED RUNTIME ON THE RECURSIVE SOLUTION with "MEMOIZATION"
// this is our memoize function that will improve our fib function
// we are passing in a function with fn
function memoize(fn) {
  // idea behind memoization is declaring a storage area and hold a result of the calls
  const cache = {};

  // and then we are returning a newer faster function
  // we are passing in some particular arguments in this new function
  // using the spread operator since we do not know how many arguments there will be that will get passed in our newer function
  return function(...args) {
    // this is the actual caching part of the function
    if (cache[args]) {
      return cache[args];
    }

    // need to use the apply helper
    const result = fn.apply(this, args);
    cache[args] = result;

    return result;
  };
}

function slowFib(n) {
  if (n < 2) {
    return n;
  }

  return fib(n - 1) + fib(n - 2);
}

const fib = memoize(slowFib);

module.exports = fib;
